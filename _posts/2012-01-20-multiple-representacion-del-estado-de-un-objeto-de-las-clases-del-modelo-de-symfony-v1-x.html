---
layout: post
title: Múltiple representación del estado de un objeto de las clases del modelo de
  Symfony v1.x
date: 2012-01-20 11:56:55.000000000 -05:00
type: post
published: true
status: publish
categories:
- Design Practices and Patterns
tags:
- JSON
- PHP
- Propel
- Serialization
- Strategy
- Symfony
meta:
  _edit_last: '26965888'
  tagazine-media: a:7:{s:7:"primary";s:53:"http://trialexpired.files.wordpress.com/2012/01/5.png";s:6:"images";a:5:{s:54:"http://trialexpired.files.wordpress.com/2012/01/11.png";a:6:{s:8:"file_url";s:54:"http://trialexpired.files.wordpress.com/2012/01/11.png";s:5:"width";s:3:"693";s:6:"height";s:3:"294";s:4:"type";s:5:"image";s:4:"area";s:6:"203742";s:9:"file_path";s:0:"";}s:53:"http://trialexpired.files.wordpress.com/2012/01/2.png";a:6:{s:8:"file_url";s:53:"http://trialexpired.files.wordpress.com/2012/01/2.png";s:5:"width";s:3:"636";s:6:"height";s:3:"572";s:4:"type";s:5:"image";s:4:"area";s:6:"363792";s:9:"file_path";s:0:"";}s:53:"http://trialexpired.files.wordpress.com/2012/01/3.png";a:6:{s:8:"file_url";s:53:"http://trialexpired.files.wordpress.com/2012/01/3.png";s:5:"width";s:3:"565";s:6:"height";s:3:"119";s:4:"type";s:5:"image";s:4:"area";s:5:"67235";s:9:"file_path";s:0:"";}s:54:"http://trialexpired.files.wordpress.com/2012/01/41.png";a:6:{s:8:"file_url";s:54:"http://trialexpired.files.wordpress.com/2012/01/41.png";s:5:"width";s:3:"837";s:6:"height";s:3:"239";s:4:"type";s:5:"image";s:4:"area";s:6:"200043";s:9:"file_path";s:0:"";}s:53:"http://trialexpired.files.wordpress.com/2012/01/5.png";a:6:{s:8:"file_url";s:53:"http://trialexpired.files.wordpress.com/2012/01/5.png";s:5:"width";s:4:"1020";s:6:"height";s:3:"506";s:4:"type";s:5:"image";s:4:"area";s:6:"516120";s:9:"file_path";s:0:"";}}s:6:"videos";a:0:{}s:11:"image_count";s:1:"5";s:6:"author";s:8:"26965888";s:7:"blog_id";s:8:"31371023";s:9:"mod_stamp";s:19:"2012-01-20
    17:01:37";}
  _publicize_pending: '1'
author:
  login: neb85
  email: neb.trx@gmail.com
  display_name: Neb
  first_name: ''
  last_name: ''
---
<p>¿Trabajas con Symfony Framework v1.x para desarrollar con PHP? ¿Tienes que lidiar con serializar objetos a formato JSON para ensamblar la respuesta a una petición AJAX? Si la respuesta a estas dos preguntas es afirmativa este post está dirigido a ti.</p>
<p>Hace algún tiempo trabajando en una solución informática me topé con un problema de redundancia de datos en el envío de JSON responses. La solución en cuestión ha sido desarrollada sobre PHP Symfony Framework v1.4.11 y utiliza como vista  UI enriquecidas realizadas a partir de la librería de JavaScript Ext JS.  Dichas UI se comunican con Symfony casi totalmente mediante AJAX requests y los responses son <em>wrappeados</em> en formato JSON. Y sí, como pudieron percatarse, la aplicación hace <em>fit</em> con el arquetipo RIA (Rich Internet Aplications).</p>
<p>Describiendo el problema con más claridad, sucede que en muchas de las JSON responses, para no decir que en todas, es necesario serializar diferentes representación del estado de uno o varios objetos,  lo que acarrea dos problemas:</p>
<ul>
<li>La serialización nativa que provee PHP mediante la función <em>json_encode()</em> pasa por alto los atributos con visibilidad privada o protegida.</li>
<li>La representación del estado o vista( como le llamaremos abreviadamente) de un objeto de las clases del modelo puede variar para diferentes peticiones, por ejemplo,  para una petición realizada para una visualización liviana de las provincias en el sistema, se define La representación del estado de los objetos <em>Provincia</em> como una agregación de un subconjunto de sus atributos; donde los atributos de <em>Provincia</em> serían: <em>idProvincia</em>, <em>idPais</em>, <em>nombre</em>, <em>código</em> y <em>activo</em>, y el subconjunto escogido: <em>idProvincia</em>, <em>nombre</em> y <em>activo</em>. Sin embargo para una visualización de la provincia desde la UI de administración de usuarios se definiría la representación del estado del objeto <em>Provincia</em> como el subconjunto (diferente al escogido anteriormente) de sus atributos: <em>idProvincia</em> y <em>nombre</em>, más el objeto <em>Pais</em> obtenido a partir del atributo <em>idPais</em> (llave foránea de la tabla <em>Provincia</em> que referencia a la tabla <em>Pais</em>).</li>
</ul>
<p>Cómo afectan estos problemas nuestro desempeño como developers?</p>
<ul>
<li>La incapacidad de transformar debidamente objetos a formato JSON propicia el uso de malas prácticas de diseño como transgresión de la visibilidad de los atributos de los objetos.</li>
<li>La utilización de una única representación del estado de un objeto en lugar de varias, solución comúnmente utilizada para salir rápido de un presunto problema menor, se transforma en un problema potencial de rendimiento de la aplicación debido al envío de datos innecesarios y redundantes en muchos casos. Esto sucede si por ejemplo, se realiza una consulta de objetos <em>Circunscripcion</em>  y estos tienen como atributos dos objetos <em>Municipio </em>y <em>Distrito</em> y a su vez el objeto <em>Distrito</em> tiene otro objeto <em>Municipio</em> como atributo. Como resultado cada vez que se realice una petición de objetos <em>Circunscripcion</em>  el JSON response va a contener objetos <em>Municipio</em> duplicados que se van a estar enviando  sin razón y que constituyen aprox. un 40% del peso (KB) del response (valor obtenido durante pruebas realizadas para ese caso), provocando potencialmente un problema de rendimiento en función de la cantidad de objetos a devolver en la petición y las prestaciones del server. Además, una implementación como la anterior viola el principio de diseño <em>Encapsulación del comportamiento variable</em> debido a que se serializan siempre los mismos atributos para cualquier petición que involucre objetos <em>Circunscripcion</em>  y la representación del estado de los objetos  que se necesita de estos puede variar de una UI a otra.</li>
<li>El mantenimiento de las clases implementadas es más complicado ya que se  programa para una implementación y no para interfaz. Si se encapsula el comportamiento variable y se <em>wrappea</em>  con una interfaz, el código a mantener hace gala de un acoplamiento bajo.</li>
</ul>
<p>El problema descrito  se puede remediar elegantemente de varias maneras, una de ellas es implementar una solución que utilice <em>PHP annotations</em> similar a los tan cómodos meta-atributos  de C# para definir que atributos de un objeto serían serializables y las vistas en la que estos que van a estar disponibles para serialización; esta solución depende del uso de un intérprete para los PHP annotations. En un análisis posterior decidí no apostar por dicha solución ya que ninguno de los intérpretes para PHP annotations que encontré contaba con las características que tenía en mente, salvo el de  Symfony 2, muy configurable pero algo complejo de extraer como un componente <em>stand-alone</em>. Con las mencionadas limitantes, más la de no disponer del tiempo necesario para diseñar e implementar mi propio intérprete para <em>PHP annotations</em>, decidí decantarme por una solución a lo KISS (<em>Keep It Simple Stupid</em>) que utiliza el patrón <em>Strategy</em> para encapsular el comportamiento variable,  que en este caso serían los atributos a serializar en cada una de las vistas. Por fortuna, gracias a la coincidencia del patrón de serialización para objetos y <em>arrays</em> utilizado en el formato JSON se soluciona  el problema de lidiar con múltiples definiciones de los atributos de objetos de una misma clase para describir las distintas vistas necesarias para la visualización de datos de objetos de las clases del modelo.</p>
<p>Haciendo un poco de memoria para continuar, recordemos que el patrón <em>Strategy </em>define una familia de estrategias, algoritmos, o como más comúnmente son llamados, comportamientos; los encapsula y los hace intercambiables permitiendo que cada uno varíe independientemente del contexto que lo esté utilizando.</p>
<p>En la solución en cuestión se toma como estrategia principal el algoritmo que genera una representación del estado del objeto en forma de <em>array</em> para su posterior serialización a formato JSON, en este caso la operación <em>generateJSONPrototype</em>, y se encapsula en la interfaz <em>JSONPrototypeView.</em> Esta operación recibe como parámetro un objeto <em>BaseObject</em>, del que se obtienen los datos necesarios para generar una representación del estado del objeto en forma de <em>array</em> y cuyo rol en la solución se explica más adelante.<em></em></p>
<p>Las clases de objetos concretas que implementen esta interfaz componen el dominio de vistas que puede tener un objeto de las clases del modelo de Symfony, diferenciándose unas de otras en la lógica de implementación de la operación <em>generateJSONPrototype. </em>Para ejemplificar la puesta en práctica de esta solución, se han incorporado dos vistas con sus correspondientes clases <em>NestedObjectsProvinciaView</em> y <em>StatusProcessProvinciaView</em> para visualizar respectivamente todos los atributos de la clase <em>Provincia</em> de forma anidada y un subconjunto específico de los atributos de la misma clase en cualquier UI donde se muestre el estado de un proceso. Este dominio de vistas constituye la familia de estrategias definidas.</p>
<p style="text-align:center;"><a href="http://trialexpired.files.wordpress.com/2012/01/11.png"><img class="aligncenter size-full wp-image-21" title="JSONPrototypeView Interface" src="{{ site.baseurl }}/assets/11.png" alt="" width="645" height="273" /></a></p>
<p>Mientras tanto el contexto que utiliza la familia de estrategias se ve comprendido por la clase <em>BaseObject</em> y sus subclases. <em>BaseObject</em> es una clase abstracta que define el comportamiento general de las clases del modelo generadas por Propel, el ORM de Symfony, así como la interfaz <em>Persistent</em> lo hace con las operaciones relativas a la persistencia.</p>
<p style="text-align:center;"><a href="http://trialexpired.files.wordpress.com/2012/01/2.png"><img class="aligncenter size-full wp-image-16" title="Symfony Model Clases Partial Diagram" src="{{ site.baseurl }}/assets/2.png" alt="" width="636" height="572" /></a></p>
<p>¿Ahora bien cómo se integra la familia de estrategias con el contexto que la va utilizar para darle solución al problema?</p>
<p>Para ello definimos una interfaz<em> JSONPrototypeViewable</em> con las operaciones <em>getJSONPrototype</em>, <em>setJSONPrototypeView </em>y<em> setJSONPrototypeView</em>, que se pueden realizar sobre un objeto de las clases del modelo para obtener las distintas vistas para su serialización. La operación <em>getJSONPrototype, </em>la principal del comportamiento definido en la interfaz, devuelve una descripción del estado del objeto <em>array like</em> (recuerden que el formato JSON representa a objetos y arreglos con el mismo patrón) según la estrategia del atributo de tipo <em>JSONProtypeView</em> que posee el objeto que implementa la interfaz, y que puede ser inyectado (aquí se pone de manifiesto el enfoque más sencillo del patrón Dependency Injection) mediante las otras dos operación de la interfaz: <em>setJSONPrototypeView </em>y<em> setJSONPrototypeView.</em> Esta operación además cuenta con un parámetro que le permite inyectar un objetio que cumpla con la interfaz <em>JSONProtypeView</em> para obtener la representación del estado correspondiente sin modificar el atributo homólogo.</p>
<p><a href="http://trialexpired.files.wordpress.com/2012/01/3.png"><img class="aligncenter size-full wp-image-17" title="getJSONPrototypeView Operation Implementation" src="{{ site.baseurl }}/assets/3.png" alt="" width="565" height="119" /></a></p>
<p>De esta manera se desacopla totalmente la generación de la representación del estado del objeto necesaria para su serialización a formato JSON de la representación del estado del objeto del que se desea obtener. Cualquier cambio o mantenimiento en las estrategias de obtención de las representaciones se lleva a cabo en el código fuente de la clase correspondiente, así mismo se pueden agregar o eliminar tantas vistas como se desee. Así es cómo quedaría el código fuente de la clase de una de las vistas o representaciones del estado del objeto.</p>
<p><a href="http://trialexpired.files.wordpress.com/2012/01/41.png"><img class="aligncenter size-full wp-image-20" title="JSONPrototypeView Interface Implementation" src="{{ site.baseurl }}/assets/41.png" alt="" width="645" height="184" /></a></p>
<p>Para una mejor comprensión general de la solución pongo a consideración cómo queda el diagrama general con las clases implicadas.</p>
<p style="text-align:center;"><a href="http://trialexpired.files.wordpress.com/2012/01/5.png"><img class="aligncenter size-full wp-image-22" title="Solution's General Diagram Class" src="{{ site.baseurl }}/assets/5.png" alt="" width="645" height="319" /></a></p>
<p>En la solución propuesta obtenemos un diseño sencillo y rápido de implementar, limpio y desacoplado para el problema descrito, aunque  no se detalla como ocurre el proceso de serialización a formato JSON porque es material para un próximo post.</p>
<p>Estén atentos, que la elasticidad de los lenguajes débilmente tipados no los haga perder la costumbre de realizar diseños flexibles y desacoplados. ¡Hasta la próxima!</p>
